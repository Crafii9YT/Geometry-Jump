<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>GeoDash Stable Version</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@900&display=swap');
        
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Roboto', sans-serif; color: white; user-select: none; }
        
        #game-container {
            position: relative; width: 100vw; height: 100vh;
            background: linear-gradient(to bottom, #200122, #6f0000);
            display: flex; justify-content: center; align-items: center;
        }

        canvas { display: block; border: 2px solid #555; box-shadow: 0 0 20px #000; background: #111; }

        /* UI Styles */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.7); z-index: 10;
        }
        .active { display: flex; }
        
        h1 { font-size: 3rem; margin-bottom: 20px; text-shadow: 3px 3px 0 #000; color: #ffcc00; }
        
        button {
            padding: 15px 30px; margin: 10px; font-size: 1.5rem; font-weight: bold;
            border: 3px solid white; background: #222; color: white; cursor: pointer;
            text-transform: uppercase;
        }
        button:hover { background: #444; transform: scale(1.05); }
        button:active { transform: scale(0.95); }

        .btn-green { background: #00aa00; }
        .btn-orange { background: #ffaa00; }
        .btn-red { background: #aa0000; }

        /* Editor Toolbar */
        #editor-ui {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 80px;
            background: #222; border-top: 2px solid white; display: none;
            justify-content: center; align-items: center; gap: 10px; z-index: 20;
        }
        .tool { width: 50px; height: 50px; border: 2px solid gray; cursor: pointer; display:flex; justify-content:center; align-items:center; }
        .tool.selected { border-color: lime; background: #333; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="menu" class="screen active">
        <h1>GEOMETRY DASH CLONE</h1>
        <button class="btn-green" onclick="startGame()">â–¶ PLAY</button>
        <button class="btn-orange" onclick="openEditor()">ðŸ›  EDITOR</button>
        <p style="margin-top:20px; color:#aaa; font-size: 0.8rem;">(Audio requires 'stereomadness.mp3' in folder)</p>
    </div>

    <div id="editor-ui">
        <div class="tool selected" onclick="setTool(1)" id="t1" style="color:lime">â– </div>
        <div class="tool" onclick="setTool(2)" id="t2" style="color:red">â–²</div>
        <div class="tool" onclick="setTool(0)" id="t0">Eraser</div>
        <button onclick="testLevel()" style="font-size:1rem; padding:5px 10px;">TEST</button>
        <button onclick="backToMenu()" class="btn-red" style="font-size:1rem; padding:5px 10px;">EXIT</button>
    </div>
</div>

<script>
    // --- SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Globale Variablen
    let w, h;
    let state = 'MENU'; // MENU, GAME, EDITOR
    let frameId;
    
    // Physik Konstanten
    const GRAVITY = 0.7;
    const JUMP = -12;
    const SPEED = 7;
    const TILE = 50;
    const FLOOR_OFFSET = 100;

    // Spieler
    let p = { x: 0, y: 0, dy: 0, w: 40, h: 40, rot: 0, grounded: false, dead: false };
    
    // Kamera
    let camX = 0;
    
    // Level Daten
    let levelData = [];
    let editorData = [];
    
    // Audio (Fehlertolerant)
    let audio = new Audio();
    let audioExists = false;

    // Initialisierung
    function resize() {
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;
    }
    window.addEventListener('resize', resize);
    resize();

    // Versuche Audio zu laden, aber crashe nicht wenn es fehlt
    try {
        audio.src = 'stereomadness.mp3';
        audio.addEventListener('canplaythrough', () => { audioExists = true; });
        audio.addEventListener('error', () => { console.log("Audio file not found - playing silent."); audioExists = false; });
    } catch(e) {
        console.log("Audio Error:", e);
    }

    // --- GAME LOOP ---
    function loop() {
        if(state === 'GAME') update();
        draw();
        frameId = requestAnimationFrame(loop);
    }

    // --- LOGIC ---
    function update() {
        if(p.dead) return;

        // Bewegung
        p.x += SPEED;
        camX = p.x - (w * 0.3); // Kamera folgt Spieler
        if(camX < 0) camX = 0;

        // Gravitation
        p.dy += GRAVITY;
        p.y += p.dy; // y ist hier Position von oben nach unten (Standard Canvas)

        // Boden Kollision
        let floorY = h - FLOOR_OFFSET - p.h;
        if(p.y >= floorY) {
            p.y = floorY;
            p.dy = 0;
            p.grounded = true;
            p.rot = Math.round(p.rot / 90) * 90; // Rotation reset
        } else {
            p.grounded = false;
            p.rot += 5;
        }

        // Block Kollisionen
        checkCollisions();
    }

    function checkCollisions() {
        // Optimierung: Nur BlÃ¶cke in der NÃ¤he prÃ¼fen
        let pRight = p.x + p.w;
        let pBottom = p.y + p.h;
        
        // Kleine Hitbox-Verkleinerung (fairness)
        let pad = 8; 

        levelData.forEach(obj => {
            let ox = obj.x * TILE;
            let oy = h - FLOOR_OFFSET - (obj.y * TILE); // y konvertieren (Grid startet bei 1 Ã¼ber Boden)
            
            // Ist Objekt im Bild?
            if(ox < p.x - 100 || ox > p.x + w) return;

            // AABB Check
            if (p.x + pad < ox + TILE - pad &&
                pRight - pad > ox + pad &&
                p.y + pad < oy + TILE &&
                pBottom > oy) {
                
                if(obj.type === 2) { // SPIKE
                    die();
                } else if(obj.type === 1) { // BLOCK
                    // Oben drauf landen?
                    if(p.dy > 0 && p.y + p.h <= oy + p.dy + 5) { // Toleranz
                        p.y = oy - p.h;
                        p.dy = 0;
                        p.grounded = true;
                        p.rot = Math.round(p.rot / 90) * 90;
                    } else {
                        die(); // Gegen die Wand
                    }
                }
            }
        });
    }

    function die() {
        p.dead = true;
        if(audioExists) audio.pause();
        // Kurzer Reset Timer
        setTimeout(() => {
            resetPlayer();
            if(audioExists) { audio.currentTime = 0; audio.play(); }
        }, 500);
    }

    function jump() {
        if(state === 'GAME' && p.grounded && !p.dead) {
            p.dy = JUMP;
            p.grounded = false;
        }
    }

    // --- DRAW ---
    function draw() {
        // Hintergrund
        ctx.fillStyle = (state === 'EDITOR') ? '#111' : '#200122';
        ctx.fillRect(0, 0, w, h);

        let floorY = h - FLOOR_OFFSET;

        // Boden
        ctx.fillStyle = '#000';
        ctx.fillRect(0, floorY, w, FLOOR_OFFSET);
        ctx.strokeStyle = '#fff';
        ctx.beginPath(); ctx.moveTo(0, floorY); ctx.lineTo(w, floorY); ctx.stroke();

        // Kamera Shift
        ctx.save();
        ctx.translate(-camX, 0);

        // Level Objekte zeichnen
        let data = (state === 'EDITOR') ? editorData : levelData;
        
        data.forEach(obj => {
            let x = obj.x * TILE;
            let y = floorY - (obj.y * TILE);

            if(obj.type === 1) { // Block
                ctx.fillStyle = 'cyan';
                ctx.fillRect(x, y, TILE, TILE);
                ctx.strokeStyle = 'white';
                ctx.strokeRect(x, y, TILE, TILE);
            } else if(obj.type === 2) { // Spike
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.moveTo(x, y + TILE);
                ctx.lineTo(x + TILE/2, y);
                ctx.lineTo(x + TILE, y + TILE);
                ctx.fill();
            }
        });

        // Spieler zeichnen
        if(state === 'GAME' && !p.dead) {
            ctx.translate(p.x + p.w/2, p.y + p.h/2);
            ctx.rotate(p.rot * Math.PI / 180);
            ctx.fillStyle = 'yellow';
            ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.strokeRect(-p.w/2, -p.h/2, p.w, p.h);
            ctx.restore(); // Undo Rotation
        } else {
             ctx.restore(); // Undo Camera Shift (fÃ¼r Editor Grid etc)
        }
        
        // Editor Grid Overlay
        if(state === 'EDITOR') {
             ctx.strokeStyle = 'rgba(255,255,255,0.1)';
             ctx.beginPath();
             // Vertikale Linien basierend auf CamX
             let startGrid = Math.floor(camX / TILE) * TILE;
             for(let gx = startGrid; gx < startGrid + w; gx+=TILE) {
                 ctx.moveTo(gx - camX, 0); ctx.lineTo(gx - camX, h);
             }
             ctx.stroke();
        }
    }

    // --- STEUERUNG & LEVEL ---
    
    // Einfaches Level Generieren
    function generateLevel() {
        let d = [];
        // Boden Blocks und Spikes
        for(let i=10; i<200; i++) {
            if(Math.random() > 0.8) d.push({x: i, y: 1, type: 2}); // Spike
            else if(Math.random() > 0.9) { // Block Platform
                 d.push({x: i, y: 1, type: 1});
                 d.push({x: i+1, y: 1, type: 1}); 
            }
        }
        // Garantie: Start ist leer
        d = d.filter(o => o.x > 15);
        return d;
    }

    function startGame() {
        levelData = (editorData.length > 0) ? editorData : generateLevel();
        state = 'GAME';
        document.getElementById('menu').classList.remove('active');
        document.getElementById('editor-ui').style.display = 'none';
        resetPlayer();
        if(audioExists) {
             audio.currentTime = 0; 
             audio.play().catch(e => console.log("Audio Autoplay blocked"));
        }
        loop();
    }

    function resetPlayer() {
        p.x = 0;
        p.y = h - FLOOR_OFFSET - p.h;
        p.dy = 0;
        p.rot = 0;
        p.dead = false;
        p.grounded = true;
        camX = 0;
    }

    // --- EDITOR ---
    let currentTool = 1;
    function openEditor() {
        state = 'EDITOR';
        document.getElementById('menu').classList.remove('active');
        document.getElementById('editor-ui').style.display = 'flex';
        camX = 0;
        if(editorData.length === 0) editorData = [];
        draw(); // Einmal zeichnen
        loop(); // Loop starten
    }

    function setTool(t) {
        currentTool = t;
        document.querySelectorAll('.tool').forEach(e => e.classList.remove('selected'));
        document.getElementById('t'+t).classList.add('selected');
    }

    function testLevel() {
        levelData = JSON.parse(JSON.stringify(editorData));
        state = 'GAME';
        document.getElementById('editor-ui').style.display = 'none';
        resetPlayer();
    }
    
    function backToMenu() {
        state = 'MENU';
        document.getElementById('menu').classList.add('active');
        document.getElementById('editor-ui').style.display = 'none';
        if(audioExists) audio.pause();
        cancelAnimationFrame(frameId);
    }

    // Inputs
    window.addEventListener('keydown', e => {
        if(e.code === 'Space' || e.code === 'ArrowUp') jump();
        if(state === 'EDITOR') {
            if(e.code === 'ArrowRight') camX += 20;
            if(e.code === 'ArrowLeft') camX -= 20;
            if(camX < 0) camX = 0;
        }
    });
    window.addEventListener('mousedown', e => {
        if(state === 'GAME') jump();
        
        if(state === 'EDITOR') {
            // Editor Platzierung
            let rect = canvas.getBoundingClientRect();
            let mx = e.clientX - rect.left + camX;
            let my = e.clientY - rect.top;
            
            let floorY = h - FLOOR_OFFSET;
            let gy = Math.ceil((floorY - my) / TILE);
            let gx = Math.floor(mx / TILE);

            if(gy >= 1) { // Nicht unter Boden
                // Erst lÃ¶schen wenn vorhanden
                editorData = editorData.filter(o => !(o.x === gx && o.y === gy));
                // Dann setzen
                if(currentTool > 0) {
                    editorData.push({x: gx, y: gy, type: currentTool});
                }
            }
        }
    });

</script>
</body>
</html>
